#include "Player.h"
#include "Game.h"
#include <iostream>
#include <fstream>

// ! This attribute should be revised if the implementation of MakeMove(...) method is changed.
const int EvaluationFunctionPlayer::NUMBER_OF_COEF_IN_EVAL_FUN = 16;

EvaluationFunctionPlayer::EvaluationFunctionPlayer(const vector<double> & evaluation_function,
                                                   bool do_simulation_of_movement,
                                                   int simulate_move_distance,
                                                   int moves_look_forward,
                                                   bool console_output) :
                                                     evaluationFunction(evaluation_function),
                                                     DO_SIMULATION_OF_MOVEMENT(do_simulation_of_movement),
                                                     SIMULATE_MOVE_DISTANCE(simulate_move_distance),
                                                     MOVES_LOOK_FORWARD(moves_look_forward),
                                                     CONSOLE_OUTPUT(console_output)
{}


vector<double> EvaluationFunctionPlayer::GetEvaluationFunction() const
{
  return this->evaluationFunction;
}


int EvaluationFunctionPlayer::MakeMove(const vector<int> & firstHorsesOfPlayers,
                                       const vector<int> & secondHorsesOfPlayers,
                                       const vector<int> & positionsOfHorses,
                                       int diceNumber,
                                       const vector<bool> & availableHorsesToMove,
                                       int playersTurn,
                                       int distance
                                       ) const
{
  // The method at first moves the horse. If the move does not finish the game, then
  // either the simulation or the looking forward by n moves is done:
  //   - For simulation: all horses, that are able to move, are moved forward for
  //     SIMULATE_MOVE_DISTANCE positions.
  //   - For looking forward: Expectiminimax is done, assuming that each player will try
  //     to maximize their own game outcome.
  // The game state, that is generated by moving (and simulating)
  // is evaluated: at first all parameter values are calculated, then the evaluation function
  // value is calculated (which is a summation of products of coefficients and parameter values).
  // This way all possible moves are evaluated, the best move is found, and the player
  // makes this move. The method returns the index of the horse, which player chooses to move.


  // Create a vector with all possible moves, so that it is easier to work with them
  // vector onlyAvailableMoves contains indexes of horses that are available to move
  vector<int> onlyAvailableMoves;
  for (unsigned int i = 0; i < availableHorsesToMove.size(); i++)
    if (availableHorsesToMove[i] == true)
      onlyAvailableMoves.push_back(i);

  vector<double> moveEvaluations;

  // Evaluate every move:
  for (vector<int>::const_iterator horseMovedIter = onlyAvailableMoves.begin();
    horseMovedIter != onlyAvailableMoves.end(); horseMovedIter++)
  {
    // During each iteration the state of the game after available move is evaluated.
    // horseMovedIter is an iterator to the index of the horse which is available to move

    // copy vector of positions of horses before moving any:
    vector<int> positionsAfterTheMove = positionsOfHorses;

    // *horseThatIsMoved is a position value of the horse that is moved this turn
    // in vector positionsAfterTheMove
    vector<int>::iterator horseThatIsMoved = positionsAfterTheMove.begin() + (*horseMovedIter);

    // move the horse:
    (*horseThatIsMoved) += diceNumber;
    if ((*horseThatIsMoved) > distance)
      (*horseThatIsMoved) = distance;

    // the variable will be used to write the move evaluation in it:
    double moveEvaluation;

    // If the move does not finish the game, then...
    if((*horseThatIsMoved) < distance)
    {
      if (DO_SIMULATION_OF_MOVEMENT)
      {
        // Simulate that all horses, that are available to move this turn,
        // except the one that is moved (not simulated),
        // are moved forward for SIMULATE_MOVE_DISTANCE positions
        SimulateMovement(positionsAfterTheMove, onlyAvailableMoves, horseMovedIter, distance);

        // For testing:
        if (CONSOLE_OUTPUT)
        {
          Console::PrintMessage("From EvaluationFunctionPlayer::MakeMove():\n");
          Console::DisplayPlayersHorses(firstHorsesOfPlayers, secondHorsesOfPlayers);
          Console::PrintMessage("Before simulation and movement:\n");
          Console::DisplayGameState(positionsOfHorses, diceNumber,
                                      availableHorsesToMove, playersTurn, (*horseMovedIter));
          Console::PrintMessage("After simulation and movement:\n");
          Console::DisplayGameState(positionsAfterTheMove, diceNumber,
                                      availableHorsesToMove, playersTurn, (*horseMovedIter));
          Console::WaitForEnterButton();
        }

        // evaluate the move:
        moveEvaluation = this->EvaluateState(firstHorsesOfPlayers, secondHorsesOfPlayers,
          positionsAfterTheMove, diceNumber, availableHorsesToMove, playersTurn, (*horseMovedIter), distance);

      }
      else if (MOVES_LOOK_FORWARD > 0)
      {
        // the player will look forward for MOVES_LOOK_FORWARD moves.

        // create vector of bool, that determine which players will need the state evaluation
        const int playerCount = firstHorsesOfPlayers.size();
        vector<bool> playersThatNeedEvaluation(playerCount, false);
        playersThatNeedEvaluation[playersTurn] = true;

        // prepare the vector of available moves:
        vector<bool> availableHorsesToMoveNextTurn = availableHorsesToMove;
        availableHorsesToMoveNextTurn[(*horseMovedIter)] = false;

        // Just to be sure. If all elements of  the availableHorsesToMoveNextTurn vector are false values,
        // than the turn will be passed to the next player. So all elements of
        // availableHorsesToMoveNextTurn shall be set to true:
        int nextPlayersTurn;
        vector<bool>::const_iterator iter = availableHorsesToMoveNextTurn.begin();
        while (iter != availableHorsesToMoveNextTurn.end() && (*iter) == false)
          iter++;
        if (iter == availableHorsesToMoveNextTurn.end())
        {
          for (vector<bool>::iterator modIter = availableHorsesToMoveNextTurn.begin();
            modIter != availableHorsesToMoveNextTurn.end(); modIter++)
              (*modIter) = true;
          nextPlayersTurn = playersTurn + 1;
          if (nextPlayersTurn >= (int) firstHorsesOfPlayers.size())
            nextPlayersTurn = 0;
        }
        // Otherwise the next turn is made by the current player:
        else
          nextPlayersTurn = playersTurn;

        double sumOfMoveEvaluations = 0.0;

        // for all possible dice numbers add next move evaluation to the sum of evaluations:
        for (int diceNumberForNextTurn = 1; diceNumberForNextTurn <= (int) Game::MAX_DICE_NUMBER;
          diceNumberForNextTurn++)
        {

          // For testing:
          if (CONSOLE_OUTPUT)
          {
            Console::PrintMessage("From EvaluationFunctionPlayer::MakeMove():\n");
            Console::PrintMessage("Coming from depth ");
            Console::DisplayDouble(MOVES_LOOK_FORWARD);
            Console::PrintMessage("\n");
            Console::DisplayGameState(positionsAfterTheMove, diceNumber, availableHorsesToMove,
                                        nextPlayersTurn, (*horseMovedIter));
            Console::PrintMessage("\n");
          }

          vector<double> lookForwardEvaluationsForPlayers = this->LookForwardAndEvaluate(
                                                                        firstHorsesOfPlayers,
                                                                        secondHorsesOfPlayers,
                                                                        positionsAfterTheMove,
                                                                        diceNumberForNextTurn,
                                                                        availableHorsesToMoveNextTurn,
                                                                        nextPlayersTurn,
                                                                        distance,
                                                                        playersThatNeedEvaluation,
                                                                        MOVES_LOOK_FORWARD - 1);

          sumOfMoveEvaluations += lookForwardEvaluationsForPlayers[playersTurn];
        }

        // calculate the average move evaluatuon:
        moveEvaluation = sumOfMoveEvaluations / Game::MAX_DICE_NUMBER;

        // For testing:
        if (CONSOLE_OUTPUT)
        {
          Console::PrintMessage("From EvaluationFunctionPlayer::MakeMove():\n");
          Console::PrintMessage("Doing looking forward: average move evaluation = ");
          Console::DisplayDouble(moveEvaluation);
          Console::PrintMessage("\n");
          Console::WaitForEnterButton();
        }
      }

      // else if (MOVES_LOOK_FORWARD == 0)
      else
      {
        // Do not do anything clever. Just move the horse and evaluate the move.

        // For testing:
        if (CONSOLE_OUTPUT)
        {
          Console::PrintMessage("From EvaluationFunctionPlayer::MakeMove():\n");
          Console::PrintMessage("Do not do anything \"clever\"\n");
        }

        // evaluate the move without doing anything "clever":
        moveEvaluation = this->EvaluateState(firstHorsesOfPlayers, secondHorsesOfPlayers,
          positionsAfterTheMove, diceNumber, availableHorsesToMove, playersTurn, (*horseMovedIter), distance);

      }
    }

    // the move finishes the game
    else
    {
      // evaluate the move:
      moveEvaluation = this->EvaluateState(firstHorsesOfPlayers, secondHorsesOfPlayers,
          positionsAfterTheMove, diceNumber, availableHorsesToMove, playersTurn, (*horseMovedIter), distance);
    }


    // ================================================================================= //

    // add evaluation of current move to the vector of move evaluations:
    moveEvaluations.push_back(moveEvaluation);

    if (CONSOLE_OUTPUT)
    {
      Console::PrintMessage("moveEvaluation = ");
      Console::PrintDouble(moveEvaluation);
      Console::PrintMessage("\n//-----------------------------------------------------------//\n\n");
      Console::WaitForEnterButton();
    }

  }
  // Evaluation of all moves is complete.
  // moveEvaluations vector is ready.

  // find the best (maximal) move evaluation:
  double bestEvaluation = moveEvaluations[0];
  double bestEvaluationIndex = 0;
  for (unsigned int i = 1; i < moveEvaluations.size(); i++)
  {
    double currentMoveEvaluation = moveEvaluations[i];
    if (currentMoveEvaluation > bestEvaluation)
    {
      bestEvaluation = currentMoveEvaluation;
      bestEvaluationIndex = i;
    }
  }

  // For testing:
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("From EvaluationFunctionPlayer::MakeMove():\n");
    Console::PrintMessage("Final decision. The maximal evaluation is ");
    Console::DisplayDouble(bestEvaluation);
    Console::PrintMessage("\n\n");
  }

  // Elements in vectors moveEvaluations and onlyAvailableMoves correspond to each other.
  // So the best move is the bestEvaluationIndex-th element of onlyAvailableMoves vector:
  int evaluationFunctionPlayerMove = onlyAvailableMoves[bestEvaluationIndex];

  return evaluationFunctionPlayerMove;
}


vector<double> EvaluationFunctionPlayer::LookForwardAndEvaluate(
                                                        const vector<int> & firstHorsesOfPlayers,
                                                        const vector<int> & secondHorsesOfPlayers,
                                                        const vector<int> & positionsAfterTheLastMove,
                                                        int diceNumber,
                                                        const vector<bool> & availableHorsesToMove,
                                                        int playersTurn,
                                                        int distance,
                                                        const vector<bool> & playersThatNeedEvaluationPrev,
                                                        int movesToLookForward
                                                        ) const
{
  // The method returns vector of evaluation values of the states for all players:
  // playersTurn - index of the player who will make a move during this turn.

  // For testing:
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("From EvaluationFunctionPlayer::LookForwardAndEvaluate():\n");
    Console::PrintMessage("Came into depth ");
    Console::DisplayDouble(movesToLookForward);
    Console::PrintMessage("\n");
    Console::DisplayGameState(positionsAfterTheLastMove, diceNumber, availableHorsesToMove,
                                playersTurn, -1);
    Console::PrintMessage("\n");
  }


  // Create a vector with all possible moves, so that it is easier to work with them
  // vector onlyAvailableMoves contains indexes of horses that are available to move
  vector<int> onlyAvailableMoves;
  for (unsigned int i = 0; i < availableHorsesToMove.size(); i++)
    if (availableHorsesToMove[i] == true)
      onlyAvailableMoves.push_back(i);

  // get player count:
  const int playerCount = firstHorsesOfPlayers.size();

  // create vector of bool, that determine which players will need the state evaluation
  vector<bool> playersThatNeedEvaluation = playersThatNeedEvaluationPrev;
  playersThatNeedEvaluation[playersTurn] = true;

  // create vector of vectors of move all available move evaluations for all players:
  vector<vector<double> > allMoveEvaluationsForAllPlayers;

  // Evaluate every move:
  for (vector<int>::const_iterator horseMovedIter = onlyAvailableMoves.begin();
    horseMovedIter != onlyAvailableMoves.end(); horseMovedIter++)
  {
    // copy vector of positions of horses before moving any:
    vector<int> positionsAfterTheMove = positionsAfterTheLastMove;

    // *horseThatIsMoved is a position value of the horse that is moved this turn
    // in vector positionsAfterTheMove
    vector<int>::iterator horseThatIsMoved = positionsAfterTheMove.begin() + (*horseMovedIter);

    // move the horse:
    (*horseThatIsMoved) += diceNumber;
    if ((*horseThatIsMoved) > distance)
      (*horseThatIsMoved) = distance;

    // vector of move evaluations of the move for all players:
    vector<double> moveEvaluationForAllPlayers(playerCount, 0.0);

    // If the move does not finish the game, and (movesToLookForward > 0) then the vertece is no a leaf:
    if((*horseThatIsMoved) < distance && movesToLookForward > 0)
    {
      // The player will look forward for movesToLookForward moves.

      // Prepare the vector of available moves:
      vector<bool> availableHorsesToMoveNextTurn = availableHorsesToMove;
      availableHorsesToMoveNextTurn[(*horseMovedIter)] = false;

      // If all elements of the availableHorsesToMoveNextTurn vector are false values,
      // than the turn will be passed to the next player. So all elements of
      // availableHorsesToMoveNextTurn shall be set to true:
      // ------------------------------------ //
      int nextPlayersTurn;
      vector<bool>::const_iterator iter = availableHorsesToMoveNextTurn.begin();
      while (iter != availableHorsesToMoveNextTurn.end() && (*iter) == false)
        iter++;
      if (iter == availableHorsesToMoveNextTurn.end())
      {
        for (vector<bool>::iterator modIter = availableHorsesToMoveNextTurn.begin();
          modIter != availableHorsesToMoveNextTurn.end(); modIter++)
            (*modIter) = true;
        nextPlayersTurn = playersTurn + 1;
        if (nextPlayersTurn >= (int) firstHorsesOfPlayers.size())
          nextPlayersTurn = 0;
      }
      // Otherwise the next turn is made by the current player:
      else
        nextPlayersTurn = playersTurn;

      // ===================================== //

      vector<double> sumsOfMoveEvaluationsForAllPlayers(playerCount, 0.0);

      // for all possible dice numbers add next move evaluation to the sums of evaluations:
      for (int diceNumberForNextTurn = 1; diceNumberForNextTurn <= (int) Game::MAX_DICE_NUMBER;
        diceNumberForNextTurn++)
      {
        vector<double> lookForwardEvaluationsForPlayers = this->LookForwardAndEvaluate(
                                                                      firstHorsesOfPlayers,
                                                                      secondHorsesOfPlayers,
                                                                      positionsAfterTheMove,
                                                                      diceNumberForNextTurn,
                                                                      availableHorsesToMoveNextTurn,
                                                                      nextPlayersTurn,
                                                                      distance,
                                                                      playersThatNeedEvaluation,
                                                                      movesToLookForward - 1);

        for (int i = 0; i < playerCount; i++)
          if (playersThatNeedEvaluation[i])
            sumsOfMoveEvaluationsForAllPlayers[i] += lookForwardEvaluationsForPlayers[i];
      }

      // calculate the average evaluation values:
      for (int i = 0; i < playerCount; i++)
        if (playersThatNeedEvaluation[i])
          moveEvaluationForAllPlayers[i] = sumsOfMoveEvaluationsForAllPlayers[i] / Game::MAX_DICE_NUMBER;

    }

    // else the vertece is a leaf
    else
    {
      // evaluate the move for the leaf, for all players:
      for (int playerIndex = 0; playerIndex < playerCount; playerIndex++)
        if (playersThatNeedEvaluation[playerIndex])
          moveEvaluationForAllPlayers[playerIndex] = this->EvaluateState(firstHorsesOfPlayers,
            secondHorsesOfPlayers, positionsAfterTheMove, diceNumber, availableHorsesToMove,
            playerIndex, (*horseMovedIter), distance);
    }

    // ================================================================================= //

    // add evaluations of current move to the vector of move evaluations for all players:
    allMoveEvaluationsForAllPlayers.push_back(moveEvaluationForAllPlayers);

    // For testing:
    if (CONSOLE_OUTPUT)
    {
      Console::PrintMessage("From EvaluationFunctionPlayer::LookForwardAndEvaluate():\n");
      Console::PrintMessage("Average of evaluations at level: ");
      Console::DisplayDouble(movesToLookForward);
      Console::PrintMessage(".\nMove evaluation for all players:\n");
      Console::DisplayVectorOfDoubles(moveEvaluationForAllPlayers);
      Console::PrintMessage("\n");
      Console::WaitForEnterButton();
    }

  }

  // Evaluation of all moves for all players is complete.
  // allMoveEvaluationsForAllPlayers vector is ready.

  // For testing:
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("From EvaluationFunctionPlayer::LookForwardAndEvaluate():\n");
    Console::PrintMessage("All move evaluation for all players at level: ");
    Console::DisplayDouble(movesToLookForward);
    Console::PrintMessage(".\nAll move evaluations for all players:\n");
    for (unsigned int i = 0; i < allMoveEvaluationsForAllPlayers.size(); i++)
    {
      Console::PrintMessage("Move ");
      Console::DisplayDouble(onlyAvailableMoves[i]);
      Console::PrintMessage(":\n");
      Console::DisplayVectorOfDoubles(allMoveEvaluationsForAllPlayers[i]);
      Console::PrintMessage("\n");
    }

    Console::PrintMessage("\n");
    Console::WaitForEnterButton();
  }

  // find the best (maximal) move evaluation for the player, who makes the current move (playersTurn):
  double maximalEvaluation = allMoveEvaluationsForAllPlayers[0][playersTurn];
  double maximalEvaluationIndex = 0;
  for (unsigned int i = 1; i < allMoveEvaluationsForAllPlayers.size(); i++)
  {
    double currentMoveEvaluation = allMoveEvaluationsForAllPlayers[i][playersTurn];
    if (currentMoveEvaluation > maximalEvaluation)
    {
      maximalEvaluation = currentMoveEvaluation;
      maximalEvaluationIndex = i;
    }
  }

  // For testing:
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("From EvaluationFunctionPlayer::LookForwardAndEvaluate():\n");
    Console::PrintMessage("The maximal evaluation vector for player ");
    Console::DisplayDouble(playersTurn);
    Console::PrintMessage(" is:\n");
    Console::DisplayVectorOfDoubles(allMoveEvaluationsForAllPlayers[maximalEvaluationIndex]);
    Console::PrintMessage("\nThis vector is returned.\n");
    Console::WaitForEnterButton();
  }

  // Return evaluation values for all players, that correspond to the most
  // profitable move of the player:

  return allMoveEvaluationsForAllPlayers[maximalEvaluationIndex];
}


double EvaluationFunctionPlayer::EvaluateState(const vector<int> & firstHorsesOfPlayers,
                                               const vector<int> & secondHorsesOfPlayers,
                                               const vector<int> & positionsAfterTheMove,
                                               int diceNumber,
                                               const vector<bool> & availableHorsesToMove,
                                               int playerIndex,
                                               int movedHorseIndex,
                                               int distance
                                               ) const
{
  // !!!
  //
  // If the number of parameters is changed,
  // const int EvaluationFunctionPlayer::NUMBER_OF_COEF_IN_EVAL_FUN shall be altered!
  //
  // !!!

  // For testing:
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("From EvaluationFunctionPlayer::EvaluateState():\n");
    Console::PrintMessage("Game state:\n");
    Console::DisplayGameState(positionsAfterTheMove, diceNumber, availableHorsesToMove,
                                playerIndex, movedHorseIndex);
  }

  // Compute the parameter values:
  // --------------------------------------------------------------------------------- //

  // vector will contain all parameter values:
  vector<double> parameterValues;
  double currentParameter;

  // 0) The distance of the 1 horse of the player from the start:
  int firstHorseOfPlayerIndex = firstHorsesOfPlayers[playerIndex];
  int firstHorseOfPlayerPosition = positionsAfterTheMove[firstHorseOfPlayerIndex];
  currentParameter = (double) firstHorseOfPlayerPosition * (1.0 / (double) distance);
  parameterValues.push_back(currentParameter);
  // ----------------------------------------------------- //

  // 1) The distance of the 2 horse of the player from the start:
  int secondHorseOfPlayerIndex = secondHorsesOfPlayers[playerIndex];
  int secondHorseOfPlayerPosition = positionsAfterTheMove[secondHorseOfPlayerIndex];
  currentParameter = (double) secondHorseOfPlayerPosition * (1.0 / (double) distance);
  parameterValues.push_back(currentParameter);
  // ----------------------------------------------------- //

  // 2) The 1 horse of the player has NOT yet been moved:
  //    = 1.0 if true; = 0.0 otherwise.
  if (firstHorseOfPlayerIndex != movedHorseIndex &&
    availableHorsesToMove[firstHorseOfPlayerIndex])
      currentParameter = 1.0;
  else
    currentParameter = 0.0;
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 3) The 2 horse of the player has NOT yet been moved:
  //    = 1.0 if true; = 0.0 otherwise.
  if (secondHorseOfPlayerIndex != movedHorseIndex &&
    availableHorsesToMove[secondHorseOfPlayerIndex])
      currentParameter = 1.0;
  else
    currentParameter = 0.0;
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 4) The distance from the 1 horse of the player from the leading horse:
  //    if this horse is a leader, than value = 0.0.
  int leaderPosition = 0;
  for (vector<int>::const_iterator iter = positionsAfterTheMove.begin();
    iter != positionsAfterTheMove.end(); iter++)
      if ((*iter) > leaderPosition)
        leaderPosition = (*iter);
  currentParameter = (double) (leaderPosition - firstHorseOfPlayerPosition) *
    (1.0 / (double) distance);
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 5) The distance from the 2 horse of the player from the leading horse:
  //    if this horse is a leader, than value = 0.0.
  currentParameter = (double) (leaderPosition - secondHorseOfPlayerPosition) *
    (1.0 / (double) distance);
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 6) The game is over after this move:
  //    = 1.0 if true; = 0.0 otherwise
  vector<int>::const_iterator posIter = positionsAfterTheMove.begin();
  while (posIter != positionsAfterTheMove.end() && (*posIter) < distance)
    posIter++;
  if (posIter != positionsAfterTheMove.end())
    currentParameter = 1.0;
  else
    currentParameter = 0.0;
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 7) The 1 horse of the player has crossed the finish line:
  //    = 1.0 if true; = 0.0 otherwise
  if (positionsAfterTheMove[firstHorseOfPlayerIndex] == distance)
    currentParameter = 1.0;
  else
    currentParameter = 0.0;
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 8) The 2 horse of the player has crossed the finish line:
  //    = 1.0 if true; = 0.0 otherwise
  if (positionsAfterTheMove[secondHorseOfPlayerIndex] == distance)
    currentParameter = 1.0;
  else
    currentParameter = 0.0;
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 9) The distance between the 1 horse of the player from the 2 horse:
  //    = 0.5 if their positions are equal;
  //    [0.0; 0.5) if the 2 horse outstrips the 1 one;
  //    (0.5; 1.0] if the 1 horse outstrips the 2 one.
  currentParameter = 0.5 + ((double) (firstHorseOfPlayerPosition - secondHorseOfPlayerPosition) *
    (1.0 / (distance * 2.0)));
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 10) The distance betwee the 1 horse of the player and
  //     the leading 1 horse of all other player, except this player:
  //     = 0.5 if their positions are equal or it is the same horse;
  //     [0.0; 0.5) if the 2 horse outstrips the 1 one;
  //     (0.5; 1.0] if the 1 horse outstrips the 2 one.
  int leaderFirstHorseOfOtherPlayersPosition = 0;
  for (unsigned int i = 0; i < firstHorsesOfPlayers.size(); i++)
    if (i != (unsigned int) playerIndex)
    {
      int tempPosition = positionsAfterTheMove[firstHorsesOfPlayers[i]];
      if (tempPosition > leaderFirstHorseOfOtherPlayersPosition)
        leaderFirstHorseOfOtherPlayersPosition = tempPosition;
    }
  currentParameter = 0.5 + ((double) (firstHorseOfPlayerPosition - leaderFirstHorseOfOtherPlayersPosition) *
    (1.0 / (distance * 2.0)));
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 11) The distance betwee the 1 horse of the player and
  //     the leading 2 horse of all other player, except this player:
  //     = 0.5 if their positions are equal or it is the same horse;
  //     [0.0; 0.5) if the 2 horse outstrips the 1 one;
  //     (0.5; 1.0] if the 1 horse outstrips the 2 one.
  int leaderSecondHorseOfOtherPlayersPosition = 0;
  for (unsigned int i = 0; i < secondHorsesOfPlayers.size(); i++)
    if (i != (unsigned int) playerIndex)
    {
      int tempPosition = positionsAfterTheMove[secondHorsesOfPlayers[i]];
      if (tempPosition > leaderSecondHorseOfOtherPlayersPosition)
        leaderSecondHorseOfOtherPlayersPosition = tempPosition;
    }
  currentParameter = 0.5 + ((double) (firstHorseOfPlayerPosition - leaderSecondHorseOfOtherPlayersPosition) *
    (1.0 / (distance * 2.0)));
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 12) The distance betwee the 2 horse of the player and
  //     the leading 1 horse of all other player, except this player:
  //     = 0.5 if their positions are equal or it is the same horse;
  //     [0.0; 0.5) if the 2 horse outstrips the 1 one;
  //     (0.5; 1.0] if the 1 horse outstrips the 2 one.
  currentParameter = 0.5 + ((double) (secondHorseOfPlayerPosition - leaderFirstHorseOfOtherPlayersPosition) *
    (1.0 / (distance * 2.0)));
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 13) The distance betwee the 2 horse of the player and
  //     the leading 2 horse of all other player, except this player:
  //     = 0.5 if their positions are equal or it is the same horse;
  //     [0.0; 0.5) if the 2 horse outstrips the 1 one;
  //     (0.5; 1.0] if the 1 horse outstrips the 2 one.
  currentParameter = 0.5 + ((double) (secondHorseOfPlayerPosition - leaderSecondHorseOfOtherPlayersPosition) *
    (1.0 / (distance * 2.0)));
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 14) The distance between the 1 horse of the player and
  //     the nearest horse that is behind this horse: = 0, if there are no horses behind.
  int nerestHorseBehindPosition = firstHorseOfPlayerPosition;
  for (posIter = positionsAfterTheMove.begin(); posIter != positionsAfterTheMove.end(); posIter++)
  {
    if ((*posIter) < firstHorseOfPlayerPosition)
    {
      if (nerestHorseBehindPosition == firstHorseOfPlayerPosition ||
        (*posIter) > nerestHorseBehindPosition)
          nerestHorseBehindPosition = (*posIter);
    }
  }
  currentParameter = (double) (firstHorseOfPlayerPosition - nerestHorseBehindPosition) *
    (1.0 / (double) distance);
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // 15) The distance between the 2 horse of the player and
  //     the nearest horse that is behind this horse: = 0, if there are no horses behind.
  nerestHorseBehindPosition = secondHorseOfPlayerPosition;
  for (posIter = positionsAfterTheMove.begin(); posIter != positionsAfterTheMove.end(); posIter++)
  {
    if ((*posIter) < secondHorseOfPlayerPosition)
    {
      if (nerestHorseBehindPosition == secondHorseOfPlayerPosition ||
        (*posIter) > nerestHorseBehindPosition)
          nerestHorseBehindPosition = (*posIter);
    }
  }
  currentParameter = (double) (secondHorseOfPlayerPosition - nerestHorseBehindPosition) *
    (1.0 / (double) distance);
  parameterValues.push_back(currentParameter);
  // ===================================================== //

  // For testing:
  /*
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("From EvaluationFunctionPlayer::EvaluateState():\n");
    Console::DisplayParameters(parameterValues);
    Console::PrintMessage("\n");
  }
  */

  // =========================================================================================== //
  // =========================================================================================== //

  // Now parameterValues vector hold all parameter values,
  // and the state of the game can be evaluated:

  //number of parameters shall be equal to the constant NUMBER_OF_COEF_IN_EVAL_FUN
  if (parameterValues.size() != (int) NUMBER_OF_COEF_IN_EVAL_FUN)
    this->WrongNumberOfCoefficientsConstant();

  // number of parameters shall be equal to number of coefficients
  if (parameterValues.size() != evaluationFunction.size())
    this->WrongParameterNumber();

  // evaluate the move (compute the scalar value):
  double stateEvaluation = 0.0;
  for (unsigned int i = 0; i < parameterValues.size(); i++)
    stateEvaluation += evaluationFunction[i] * parameterValues[i];

  // For testing:
  if (CONSOLE_OUTPUT)
  {
    Console::PrintMessage("State evaluation: ");
    Console::DisplayDouble(stateEvaluation);
    Console::PrintMessage("\n");
    Console::WaitForEnterButton();
  }

  return stateEvaluation;
}


void EvaluationFunctionPlayer::SimulateMovement(vector<int> & positionsAfterTheMove,
                                                const vector<int> & onlyAvailableMoves,
                                                const vector<int>::const_iterator horseMovedIter,
                                                int distance
                                                ) const
{
  // Method simulates that all horses, that are available to move,
  // except the one that is moved (not simulated),
  // are moved forward for SIMULATE_MOVE_DISTANCE positions

  vector<int>::iterator horseThatIsSimulated;
  for (vector<int>::const_iterator simulatedMoveIter = onlyAvailableMoves.begin();
    simulatedMoveIter != onlyAvailableMoves.end(); simulatedMoveIter++)
    if (simulatedMoveIter != horseMovedIter)
    {
      // *horseThatIsSimulated is a position value of the horse that is simulated to move
      // this turn in vector positionsAfterTheMove
      horseThatIsSimulated = positionsAfterTheMove.begin() + (*simulatedMoveIter);
      (*horseThatIsSimulated) += SIMULATE_MOVE_DISTANCE;
      if ((*horseThatIsSimulated) > distance)
        (*horseThatIsSimulated) = distance;
  }
}


bool EvaluationFunctionPlayer::LoadEvaluationFunction(const char * file_name)
{
  // Method loads the evaluation function coefficients from the file:
  // Returns true if the loading has been completed successfully; false - otherwise.

  ifstream fin(file_name);
  if (!fin.is_open())
  {
    if (CONSOLE_OUTPUT)
    {
      Console::PrintMessage("Error! From EvaluationFunctionPlayer::LoadEvaluationFunction():\nFile ");
      Console::PrintMessage(file_name);
      Console::PrintMessage(" is not found!\n");
      Console::WaitForEnterButton();
    }
    return false;
  }

  vector<double> loadedEvaluationFunction;
  double currentCoefficient;
  int currentCoefficientNumber = 0;
  while (currentCoefficientNumber < NUMBER_OF_COEF_IN_EVAL_FUN && !fin.eof())
  {
    fin >> currentCoefficient;

    if (fin.fail())
    {
      if (CONSOLE_OUTPUT)
      {
        Console::PrintMessage("Error! From EvaluationFunctionPlayer::LoadEvaluationFunction():\nFile ");
        Console::PrintMessage(file_name);
        Console::PrintMessage(" contains not valid data!\n");
        Console::WaitForEnterButton();
      }
      fin.close();
      return false;
    }
    else
    {
      loadedEvaluationFunction.push_back(currentCoefficient);
      currentCoefficientNumber++;
    }
  }

  fin.close();

  if (currentCoefficientNumber < NUMBER_OF_COEF_IN_EVAL_FUN)
  {
    if (CONSOLE_OUTPUT)
    {
      Console::PrintMessage("Error! From EvaluationFunctionPlayer::LoadEvaluationFunction():\nFile ");
      Console::PrintMessage(file_name);
      Console::PrintMessage(" contains less values than needed!\n");
      Console::WaitForEnterButton();
    }
    return false;
  }
  else if (loadedEvaluationFunction.size() != (int) NUMBER_OF_COEF_IN_EVAL_FUN)
  {
    if (CONSOLE_OUTPUT)
    {
      Console::PrintMessage("Error! From EvaluationFunctionPlayer::LoadEvaluationFunction():\n");
      Console::PrintMessage("Bug in the method!\n");
      Console::WaitForEnterButton();
    }
    return false;
  }
  else
  {
    evaluationFunction = loadedEvaluationFunction;
    return true;
  }

}


void EvaluationFunctionPlayer::WrongParameterNumber() const
{
  Console::PrintMessage("ERROR!\nFrom EvaluationFunctionPlayer:\n");
  Console::PrintMessage("Number of parameters and number of coefficients are not equal!\n");
  Console::WaitForEnterButton();
  exit(EXIT_FAILURE);
}


void EvaluationFunctionPlayer::WrongNumberOfCoefficientsConstant () const
{
  Console::PrintMessage("ERROR!\nFrom EvaluationFunctionPlayer:\n");
  Console::PrintMessage("NUMBER_OF_COEF_IN_EVAL_FUN constant is wrong! Bug in the source code!\n");
  Console::WaitForEnterButton();
  exit(EXIT_FAILURE);
}






















